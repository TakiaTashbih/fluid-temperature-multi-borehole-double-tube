
# -*- coding: utf-8 -*-
"""
pygfunction >= 2.3.x
4.12 — Simulation of fluid temperatures in a single borehole
Case: Single U-tube only
"""

import numpy as np
import matplotlib.pyplot as plt
import pygfunction as gt


def main():
    # ---------------------------------------------------------------
    # Simulation parameters
    # ---------------------------------------------------------------

    # Borehole dimensions
    D   = 4.0       # burial depth [m]
    H   = 150.0     # length [m]
    r_b = 0.075     # borehole radius [m]

    # Pipe dimensions
    r_out   = 0.0211    # outer radius [m]
    r_in    = 0.0147    # inner radius [m]
    D_s     = 0.052     # shank spacing [m]
    epsilon = 1.0e-6    # roughness [m]

    # Pipe positions (x,y) — Single U-tube: [(x_in, y_in), (x_out, y_out)]
    pos_single = [(-D_s, 0.0), ( D_s, 0.0)]

    # Ground
    alpha = 1.0e-6    # thermal diffusivity [m2/s]
    k_s   = 2.0       # thermal conductivity [W/m.K]
    T_g   = 10.0      # undisturbed ground temperature [°C]

    # Grout / pipe conductivity
    k_g = 1.0         # grout [W/m.K]
    k_p = 0.4         # pipe  [W/m.K]

    # Fluid (20% MPG at 20°C)
    m_flow = 0.25                         # mass flow rate [kg/s]
    fluid  = gt.media.Fluid('MPG', 20.0)
    cp_f   = fluid.cp
    rho_f  = fluid.rho
    mu_f   = fluid.mu
    k_f    = fluid.k

    # g-Function options
    options = {'nSegments': 8, 'disp': True}

    # Time grid (1 year, hourly)
    dt    = 3600.0
    tmax  = 8760.0 * 3600.0
    Nt    = int(np.ceil(tmax / dt))
    time  = dt * np.arange(1, Nt + 1)

    # ---------------------------------------------------------------
    # Loads (Bernier synthetic profile)
    # ---------------------------------------------------------------
    Q = synthetic_load(time / 3600.0)  # W (heat extraction rate)

    # ---------------------------------------------------------------
    # Load aggregation
    # ---------------------------------------------------------------
    LoadAgg = gt.load_aggregation.ClaessonJaved(dt, tmax)

    # ---------------------------------------------------------------
    # g-function (single borehole, UBWT boundary)
    # ---------------------------------------------------------------
    borehole = gt.boreholes.Borehole(H, D, r_b, x=0.0, y=0.0)
    time_req = LoadAgg.get_times_for_simulation()
    gFunc = gt.gfunction.gFunction(
        borehole, alpha, time=time_req, boundary_condition='UBWT',
        options=options
    )
    LoadAgg.initialize(gFunc.gFunc / (2.0 * np.pi * k_s))

    # ---------------------------------------------------------------
    # Pipe model (Single U-tube)
    # ---------------------------------------------------------------
    # Pipe wall conduction resistance
    R_p = gt.pipes.conduction_thermal_resistance_circular_pipe(r_in, r_out, k_p)

    # Fluid-wall convection
    h_f = gt.pipes.convective_heat_transfer_coefficient_circular_pipe(
        m_flow, r_in, mu_f, rho_f, k_f, cp_f, epsilon
    )
    R_f = 1.0 / (h_f * 2.0 * np.pi * r_in)

    SingleUTube = gt.pipes.SingleUTube(
        pos_single, r_in, r_out, borehole, k_s, k_g, R_f + R_p
    )

    # ---------------------------------------------------------------
    # Simulation loop
    # -----------------------------
# Simulation loop (cooling → wall warms)
# -----------------------------
T_b            = np.zeros(Nt)    # borehole wall temperature
T_f_in_single  = np.zeros(Nt)
T_f_out_single = np.zeros(Nt)

for i, (t, Q_i) in enumerate(zip(time, Q)):
    LoadAgg.next_time_step(t)
    LoadAgg.set_current_load(Q_i / H)          # W/m

    dT_b = LoadAgg.temporal_superposition()
    T_b[i] = T_g + dT_b                        # cooling/injection → wall above Tg

    # use Q_i consistently
    T_f_in_single[i]  = SingleUTube.get_inlet_temperature(Q_i, T_b[i], m_flow, cp_f)
    T_f_out_single[i] = SingleUTube.get_outlet_temperature(T_f_in_single[i], T_b[i], m_flow, cp_f)

# -----------------------------
# Plots — show ONLY Mar 15 → Jul 31
# -----------------------------
hours = time / 3600.0  # hour-of-year, 0..8760

def hour_of_year(m, d, h):
    dim = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
    return (sum(dim[:m-1]) + (d-1))*24 + h

hs = hour_of_year(3, 15, 0)      # Mar 15 00:00
he = hour_of_year(7, 31, 24)     # Jul 31 24:00 (exclusive end)
mask = (hours >= hs) & (hours <= he)

fig = gt.utilities._initialize_figure()

# Load (ground heat rejection)
ax1 = fig.add_subplot(211)
gt.utilities._format_axes(ax1)
ax1.plot(hours[mask], Q[mask], lw=1.2)
ax1.set_xlim(hs, he)
ax1.set_xlabel('Time [hours]')
ax1.set_ylabel('Ground heat rejection [W]')

# Temperatures
ax2 = fig.add_subplot(212)
gt.utilities._format_axes(ax2)
ax2.plot(hours[mask], T_b[mask], 'k-', lw=1.5, label='Borehole wall')
ax2.plot(hours[mask], T_f_out_single[mask], '--', label='Outlet, single U-tube')
ax2.set_xlim(hs, he)
ax2.set_xlabel('Time [hours]')
ax2.set_ylabel('Temperature [°C]')
ax2.legend()

plt.tight_layout()

def synthetic_load(x_hours):
    """
    Synthetic load profile of Bernier et al. (2004).
    Returns load y (in watts) at time x (in hours).
    """
    A = 2000.0; B = 2190.0; C = 80.0; D = 2.0; E = 0.01; F = 0.0; G = 0.95
    func = (168.0 - C) / 168.0
    for i in [1, 2, 3]:
        func += (1.0 / (i * np.pi)) * (np.cos(C * np.pi * i / 84.0) - 1.0) \
              * (np.sin(np.pi * i / 84.0 * (x_hours - B)))
    func = func * A * np.sin(np.pi / 12.0 * (x_hours - B)) \
               * np.sin(np.pi / 4380.0 * (x_hours - B))
    y = func + (-1.0)**np.floor(D/8760.0*(x_hours - B)) * np.abs(func) \
        + E * (-1.0)**np.floor(D/8760.0*(x_hours - B)) \
          / np.sign(np.cos(D*np.pi/4380.0*(x_hours - F)) + G)
    return -y


if __name__ == "__main__":
    main()
